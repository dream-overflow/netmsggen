Net Message Generator
=====================

This tool provides any easy way to generate C++ code from a pseudo language that describes
network messages passed between a client and a server.

It is related to O3D types, but it can be easily modified to support more standards
types, or more specifics (to your own library).

Usage : nmg <path>

Path is where to find the netmessagegen file, and base path for any relative path found
in the netmessagegen file. The content of netmessagegen is describes below of this
document.


++++++
Target
++++++

A target is the client or the server.


+++++++++++++++++++
Language definition
+++++++++++++++++++

.msg is the extension for the source files. Only *.msg files are parsed.

# define a comment line
msg keyword to define a generated message
abstract keyword define an abstract (non generated message)
import keyword define a name of a message file to import (without the .msg extension)

A <Name> contain letters, and numerical, and _, like in C/C++.

example:
# a message
import BaseMessage

msg MyMessage<13> : BaseMessage
{
	@client in
	@server out
	
	int8 age
	bool sex
	string name
	
	int8[4] specificities
}

A file can contain many messages, many abstracts messages, many comments lines,
and many import directives.

Each file mean a related set of exported file for the targets.
If you want one class in one specific file per message you have to write only one message
per file.


-----------
msg message
-----------

msg <NAME><optional\<INTEGER\>><:NAME>
{
	@client <in|out|both|none>
	@server <in|out|both|none>
	
	<expressions...>
}

A message have a unique name, and its code is auto-generated by incrementing a global
counter. But it is possible to set some message code manualy in <INTEGER>.

Example: msg MyMessage<13>

Inheritance is possible using the : after the message name and <code>.
The inherit msg must exist in the file, or be imported using the import directive.

Example: msg MyMessage<13> : BaseMessage

The inherited message can be a msg or an abstract.

@client and @server define how the message is exported on each target (client, server).
in, mean as an input message, out as an output message, none mean not exported.
If a target is not specified, both is the default value.

A message generate a class, with setters, read, write and run methods.
The class name is NameOfTheMessage<In|Out>. In for input, with a readFromBuffer and run
methods, and Out for output with a writeToBuffer method.

Setters are auto-generated on outgoing messages, for each variable, conditions, loop.
On incoming message, the run method on the MessageNameIn.run.<cppext> must be filled with
you own code.

Generated files are :

 - MessageName<In>.<hppext>
 - MessageName<In>.<cppext>
 - MessageName<In>.run.<cppext>
 - MessageName<Out>.<hppext>
 - MessageName<Out>.<cppext>
 
One or every of these files are generated per target (client, server).
If the message is both, all files are generated, if the target is in only <In> files are
generated, and respectively for <Out>.


----------------
abstract message
----------------

An abstract is never exported, it only can be used for inheritance.
Example:
 abstract BaseMessage
 {
 	int8 type
 }


--------------------------------
expressions, core of the message
--------------------------------

A message can contain different type of expressions :

- constants (const, public const <NAME|INTEGER>, bit)
- variables
- conditions (boolean test if)
- loops (named loop)


-----
types
-----

Constants, and variables are typed :

- bool Boolean
- int8, uint8 signed, unsigned 1 byte
- int16, uint16
- int32, uint32
- int64, uint64
- float, 4 bytes float
- double, 8 bytes double
- string, utf8 sized string
- bitset8, bitset16, bitset32, bitset64, bit field size on a byte, 2, 4 and 8
- array8, dynamic array of bytes
- <TYPENAME>[], static array of typename (example: int8[4] forBytes)


---------
constants
---------

<public> const <TYPENAME> <NAME> = <LITTERAL|IMMEDIATE>
bit <NAME>[LITTERAL]


const
-----

A const can be public.
Examples:
  public const int8 MyConst = 4
  const int32 AConst = GENDER

A const typename can be a simple type (u)int(n), float or double, or string.
The value of the const can be a litteral or an immediate.

A litteral mean a name, and the value is an auto-generated integer, relative to its scope.
An immediate value must be a integer, float, double or string.


bit
---

A bit is always private, and it is related to an existing bitset<n>.
Example: bit myFlags[FRIEND]

The value is auto-generated by the bitset, and is unique.


---------
variables
---------

A variable generate private members in the class of the message.

===============================
/!\ TODO DOCUMENT THIS PART /!\
===============================


-----
loops
-----

Loops are simples iterations, for 0 to n, and loops are named, causing the generation of
a struct, and a scope.

Example:
	int8 counter
	loop Friend : counter
	{
		string name
		int8 affinity	
	}
	
A struct Friend is created, and contain the name and affinity variables.
For each value of the counter, a Friend is read/write.

You can have conditions in loop, but no loops in a loop.


----------
conditions
----------


if
--

if is a simple true/false condition.
It works with any variables, 1 meaning true, 0 meaning false.
It works too with bitset like this :

Example:
	if myBitSet[HAVE_FRIENDS]
	{
		int8 counter
		loop Friend : int8 m_counter
		{
			string name
			int8 affinity	
		}
	}
	
Will create a const named HAVE_FRIENDS, with an auto-generated value for the myBitSet
bitset. In run method you can check for a bit using HAVE_FRIENDS constants on the bitset
member.

It works too with static and dynamic array. In this case the [VALUE] mean the index
into the array.

Another example:
	bool condition
	if condition
	{
		...
	}
	
It test if condition equal 1, if true, it go inside the condition.

You can have conditions and loop in if.


++++++++++++++++++++++++++++++++
metmessagegen configuration file
++++++++++++++++++++++++++++++++

The path must contain a file named netmessagegen with the following content :

version = <user choosen integer version>
author = <a string of the author>

client.namespace = <client side simple namespace name where to generate code>
server.namespace = <server side simple namespace name where to generate code>

client.messageFactory.instance = <on client, static accessible o3d::net::NetMessageFactory instance>
server.messageFactory.instance = <on server, static accessible o3d::net::NetMessageFactory instance>
client.messageFactory.header = <on client, header where to find the NetMessageFactory instance, with "" or <> >
server.messageFactory.header = <on server, header where to find the NetMessageFactory instance, with "" or <> >

hppext = <file extension for headers files>
cppext = <file extension for sources files>

input = <input folder containing the messages files, path is relative to its file>

client.output = <on client, output folder, where to generate the code, headers and sources, relative to this>
server.output = <on server, output folder, where to generate the code, headers and sources, relative to this>

templates = <folder where to find templates files, relative to this>

export = <client|serve|both meaning export only for client, for server or for the both>

With # Means a comment line
